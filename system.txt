
# ğŸ”§ Backend Flow: Step-by-Step for Each User Action

---

## 1ï¸âƒ£ User opens the app (backend view)

Nothing happens yet.

* No WebSocket
* No Redis
* No signaling
* No DB calls

Backend is **idle**.

---

## 2ï¸âƒ£ User logs in

### Backend flow

1. **Client â†’ Management Server**

   * Sends credentials (email/password or OAuth)

2. **Management Server**

   * Validates credentials
   * Queries **Database**
   * Checks user status (active/banned)

3. **Management Server**

   * Generates:

     * `userId`
     * Auth token (JWT/session)
   * Returns token to client

ğŸ“Œ **Signaling server is NOT involved**

---

## 3ï¸âƒ£ User creates a room

### Backend flow

1. **Client â†’ Management Server**

   * `CreateRoom` request

2. **Management Server**

   * Validates request
   * Inserts new row into `rooms` table
   * Sets creator as owner/admin

3. **Management Server â†’ Client**

   * Returns `roomId`

ğŸ“Œ No Redis
ğŸ“Œ No signaling
ğŸ“Œ Pure control + persistence

---

## 4ï¸âƒ£ User joins a room

### Backend flow

1. **Client â†’ Load Balancer**

   * Opens WebSocket request

2. **Load Balancer**

   * Selects a signaling server
   * Forwards WebSocket handshake

3. **Client â†’ Signaling Server**

   * Sends `roomId + auth token`

4. **Signaling Server â†’ Management Server (gRPC)**

   * `CanJoinRoom(userId, roomId)`

5. **Management Server**

   * Queries DB:

     * Room exists?
     * User banned?
     * Room full?
   * Returns `ALLOW` / `REJECT`

6. **Signaling Server**

   * If `ALLOW`:

     * Keeps WebSocket open
     * Maps:

       ```
       roomId â†’ user WebSocket
       ```
     * If first user of this room:

       * `SUBSCRIBE room:{roomId}` in Redis
   * If `REJECT`:

     * Closes WebSocket

---

## 5ï¸âƒ£ Another user joins the same room (different server)

### Backend flow

* Same steps as above
* Second signaling server:

  * Subscribes to the same Redis channel
* Redis now has:

  ```
  room:{roomId} â†’ [Server A, Server B]
  ```

ğŸ“Œ Redis still has no idea who users are

---

## 6ï¸âƒ£ User sends a chat message

### Backend flow (two parallel paths)

### ğŸ” A) Real-time delivery

1. **Client â†’ Signaling Server**

   * Chat message via WebSocket

2. **Signaling Server â†’ Redis**

   * `PUBLISH room:{roomId}`

3. **Redis**

   * Broadcasts message to all subscribed signaling servers

4. **Each Signaling Server**

   * Looks up local users for `roomId`
   * Sends message via WebSocket

---

### ğŸ’¾ B) Persistence

5. **Origin Signaling Server â†’ Management Server (gRPC)**

   * `StoreMessage(roomId, userId, message, timestamp)`

6. **Management Server**

   * Writes message to DB

ğŸ“Œ Delivery and storage are **decoupled**

---

## 7ï¸âƒ£ User receives chat messages

### Backend flow

* Signaling server receives Redis message
* Matches `roomId`
* Pushes message to relevant WebSocket clients

ğŸ“Œ No DB reads
ğŸ“Œ No management calls

---

## 8ï¸âƒ£ User starts a video call

### Backend flow (signaling only)

1. **Client**

   * Requests camera/mic
   * Creates WebRTC SDP offer

2. **Client â†’ Signaling Server**

   * Sends offer via WebSocket

3. **Signaling Server â†’ Redis**

   * Publishes offer to `room:{roomId}`

4. **Redis â†’ Other Signaling Servers**

   * Broadcasts offer

5. **Other Signaling Servers â†’ Clients**

   * Forward offer via WebSocket

ğŸ“Œ Backend does NOT see media
ğŸ“Œ Only signaling metadata

---

## 9ï¸âƒ£ WebRTC answer & ICE exchange

### Backend flow

* Same Redis-based path:

  ```
  Client â†’ Signaling â†’ Redis â†’ Signaling â†’ Client
  ```

ğŸ“Œ Continues until P2P connection is ready

---

## ğŸ”Ÿ Video/audio flows (backend is OUT)

* Clients establish **direct WebRTC P2P**
* Backend does NOTHING
* No Redis
* No signaling
* No DB

---

## 1ï¸âƒ£1ï¸âƒ£ Chat + call run together

### Backend behavior

* Chat continues via Redis + signaling
* WebRTC media remains P2P
* Both flows are independent

---

## 1ï¸âƒ£2ï¸âƒ£ User leaves the call

### Backend flow

1. **Client**

   * Closes WebRTC PeerConnection
   * Stops media tracks

ğŸ“Œ Backend not involved
ğŸ“Œ Other client detects ICE disconnect

---

## 1ï¸âƒ£3ï¸âƒ£ User leaves the room

### Backend flow

1. **Client**

   * Closes WebSocket

2. **Signaling Server**

   * Removes user from internal map
   * If last user in room:

     * `UNSUBSCRIBE room:{roomId}`

ğŸ“Œ Redis cleans up automatically

---

## 1ï¸âƒ£4ï¸âƒ£ User disconnects unexpectedly

### Backend flow

* WebSocket drops
* Signaling server cleans in-memory state
* Redis unsubscribes if needed

Client later reconnects and repeats join flow

---

## 1ï¸âƒ£5ï¸âƒ£ User is banned

### Backend flow

1. **Admin â†’ Management Server**

   * Ban request

2. **Management Server**

   * Updates DB
   * Sends `ForceDisconnect(userId)` via gRPC

3. **Signaling Server**

   * Closes userâ€™s WebSocket

4. **Client**

   * Detects disconnect
   * Stops WebRTC

---

## ğŸ§  Backend summary (core truth)

```
Management Server â†’ authority + persistence
Signaling Server  â†’ real-time coordination
Redis             â†’ server-to-server bridge
WebRTC            â†’ client-to-client media
```

Each does **one job only**.

---

## One-line backend summary (perfect)

> â€œThe backend separates control logic and persistence in the management layer, real-time coordination in the signaling layer bridged by Redis Pub/Sub, and offloads media transmission entirely to peer-to-peer WebRTC.â€

---


