StreamLink – Scalable Video Conferencing
Engine
1. Problem Statement
Building a video chat app for 2 people is simple. Building one that scales to thousands of users
across multiple servers is an architectural nightmare.
●​ The Conflict: WebSockets are "stateful." If User A connects to Server 1 and User B
connects to Server 2, they are effectively on different islands. Server 1 cannot just "send
a message" to User B because it doesn't hold that connection.
●​ The Risk: In a monolithic app, if the server crashes, everyone gets disconnected. In a
distributed system, users might be online but unable to see each other.
●​ The Goal: Build a distributed system where the "Signaling Layer" (WebSockets) is
horizontally scalable using Redis Pub/Sub, while a separate "Management Layer"
handles security and persistence.

2. Functional Requirements
1.​ Distributed Signaling: A user on Signaling Node A must be able to call a user on
Signaling Node B. The system must route messages between servers transparently.
2.​ Mesh Video Topology: For the actual video/audio, users connect directly to each other
(Peer-to-Peer) using WebRTC. The server only helps them find each other.
3.​ Secure Gating: Before a WebSocket connection is allowed, the Signaling Server must
ask the Management Server via gRPC: "Is this user banned? Is this room full?"
4.​ Persistent Chat: Text messages sent during the meeting must be saved to the
database, even though video streams are ephemeral.

3. Tech Stack Roles (The "Why")
Component

Technology

Role & Challenge

Manager Service

Spring Boot,
FastAPI,
Dotnet

The Bouncer. Handles User Accounts, Room
Creation, Bans, and History. It is the only
service allowed to write to the main Database.

Signaling Service

Spring Boot,
FastAPI,
Dotnet

The Switchboard. Handles thousands of open
WebSocket connections. It does not store
data; it just routes traffic between users.

Communication

gRPC +
Protobuf

The Hotline. Used for internal authorization.
The Switchboard (FastAPI) asks the Bouncer
(Spring Boot) for permission to let a user in.

Coordinator

Redis or
rabbitmq

The Bus. Connects the isolated Signaling
servers. If User A talks on Server 1, the
message is published to Redis so Server 2
can deliver it to User B.

Frontend

React or
Angular

The Client. Handles the complex WebRTC
state machine (ICE Candidates, Offers,
Answers) and media stream rendering.

Storage

PostgreSQL

The Archive. Stores User Profiles, Room
Metadata, and Chat Logs.

4. Project Milestones (1-Week Timeline)
Phase 1: The Contract & Architecture (Day 1)
●​ Focus: Protocol Design.
●​ Task:
○​ Define the .proto file for Auth (e.g., rpc CanJoinRoom(JoinRequest) returns
(AuthResponse)).
○​ Define the WebSocket JSON Protocol (e.g., { "type": "offer", "sdp": "..." }).
●​ Deliverable: A Sequence Diagram showing how a "Join" request flows from React ->
FastAPI-> gRPC -> Spring Boot.
Phase 2: The "Signaling" Skeleton (Day 2)
●​ Focus: Connectivity.
●​ Task:

○​ Create the FastAPI WebSocket endpoint.
○​ Implement a simple "Echo" server: What one user types, the server sends back.
○​ Create the Spring Boot REST API to generate a "Room ID".
●​ Deliverable: A user can connect to a WebSocket and receive a "Welcome" message.
Phase 3: The Distributed Bridge (Day 3-4)
●​ Focus: Scaling (The Hardest Part).
●​ Task:
○​ Spin up 2 instances of FastAPI on different ports.
○​ Implement Redis Pub/Sub.
○​ Test: Connect Client A to Port 8000 and Client B to Port 8001. When Client A
sends a chat message, Client B must receive it via the Redis backplane.
●​ Deliverable: Cross-server text chat working perfectly.
Phase 4: The Video Handshake (Day 5)
●​ Focus: WebRTC.
●​ Task:
○​ Implement the Frontend logic to capture the Camera/Mic
(navigator.mediaDevices).
○​ Exchange "Offers" and "Answers" via the WebSocket.
○​ Render the remote video stream in a <video> tag.
●​ Deliverable: Two users can see and hear each other.
Phase 5: The Demo (Day 6)
●​ Scenario:
1.​ Start the meeting with 3 users.
2.​ Show that Chat works instantly.
3.​ The "Chaos" Test: Ban User 3 in the Spring Boot Admin panel.
4.​ Watch as Spring Boot sends a gRPC command to FastAPI to forcibly disconnect
User 3's WebSocket.
5.​ Show that User 3 cannot rejoin.

